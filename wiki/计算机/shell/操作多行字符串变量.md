当我们在 shell 的 bash 里操作多行内容的字符串,我们往往会想到 普通的字符串处理办法 例如:

```bash
string="Hello linux"
echo $string
```

其实 bash 提供了一个非常好的解决办法,就是 **"Multi-line"**

#### 变量的基本使用

e.g. 包含变量

```bash
cat > myfile.txt <<EOF
this file has $variable $names $inside
EOF

# 注入文档到 myfile.txt
cat myfile.txt
#输入:
#this file has

variable="ONE"
names="TWO"
inside="expanded variables"

cat > myfile.txt <<EOF
this file has $variable $names $inside
EOF

#print out the content of myfile.txt
cat myfile.txt
#输入:
#this file has ONE TWO expanded variables
```

#### 无变量

```bash
cat > myfile.txt <<"EOF"
this file has $variable $dollar $name $inside
EOF

cat myfile.txt
#得到
#this file has $variable $dollar $name $inside
```

PS:引用符号 "EOF" 决定是否需要输入变量

#### 无变量 – 例子 2

```bash
cat > myfile.txt <<EOF
this file has $variable \$dollar \$name \$inside
EOF

cat myfile.txt
# 得到
# this file has $variable $dollar $name $inside
```

转义 dollar "$" 符号,bash将取消变量的解析

#### 将一个多行文本赋值到变量里面

例1:

```bash
read -d '' stringvar <<-"_EOF_"

all the leading dollars in the $variable $name are $retained

_EOF_
# 输入变量
echo $stringvar;
# all the leading dollars in the $variable $name are $retained
```

例2:

```bash
read -d '' help <<- "_EOF_"
  usage: up [--level <n>| -n <levels>][--help][--version]

  Report bugs to:
  up home page:
_EOF_
```

例3:

```bash
VARIABLE1="<?xml version=\"1.0\" encoding='UTF-8'?>
<report>
  <img src="a-vs-b.jpg"/>
  <caption>Thus is a future post on Multi Line Strings in bash
  <date>1511</date>-<date>1512</date>.</caption>
</report>"
```

例4:

```bash
VARIABLE2=$(cat <<EOF
<?xml version="1.0" encoding='UTF-8'?>
<report>
  <img src="a-vs-b.jpg"/>
  <caption>Thus is a future post on Multi Line Strings in bash
  <date>1511</date>-<date>1512</date>.</caption>
</report>
EOF
)
```

例5:

```bash
VARABLE3=`cat <<EOF
<?xml version="1.0" encoding='UTF-8'?>
<report>
  <img src="a-vs-b.jpg"/>
  <caption>Thus is a future post on Multi Line Strings in bash
  <date>1511</date>-<date>1512</date>.</caption>
</report>
EOF`
```

例6 (直接写入文件):

```bash
cat > heredocfile.txt <<_EOF_
I am line 1
I am line 2
I'm the last line
_EOF_

# 测试
cat heredocfile.txt
# I am line 1
# I am line 2
# I'm the last line

# and then, change your echo statement to include the '-e' option 
# which will turn on escape sequence processing:
echo -e $USAGE >&2
```

例7:

```bash
sudo cat > /aaaa.txt <<_EOF_
I am line 1
I am line 2
I'm the last line
_EOF_

# sudo and >>: permission denied
```

例8:

```bash
# create
sudo tee /aaa.txt << EOF
  echo "Hello World 20314"
EOF
```

例9(可向文本文件追加):

```bash
# Append to Sudo 
sudo tee -a  /aaa.txt << EOF
 echo "This Line is appended" 
EOF
```

例如10:

```bash
sudo sh -c "cat > /aaa.txt" <<"EOT"
this text gets saved as sudo - $10 - ten dollars ...
EOT

cat /aaa.txt
#this text gets saved as sudo - $10 - ten dollars ...
```

例11:

```bash
cat << "EOF" | sudo tee /aaa.txt
let's count
$one 
two
$three 
four

EOF

cat /aaa.txt
#let's count
#$one 
#two
#$three 
#four
```

关于 tee

```bash
> tee --help
Usage: tee [OPTION]... [FILE]...
Copy standard input to each FILE, and also to standard output.

  -a, --append              append to the given FILEs, do not overwrite
  -i, --ignore-interrupts   ignore interrupt signals
      --help     display this help and exit
      --version  output version information and exit

If a FILE is -, copy again to standard output.

Report tee bugs to bug-coreutils@gnu.org
GNU coreutils home page: <http://www.gnu.org/software/coreutils/>
General help using GNU software: <http://www.gnu.org/gethelp/>
For complete documentation, run: info coreutils 'tee invocation'
```

### 